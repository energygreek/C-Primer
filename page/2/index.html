<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>又是元气满满的一天</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="又是元气满满的一天">
<meta property="og:url" content="https://energygreek.github.io/page/2/index.html">
<meta property="og:site_name" content="又是元气满满的一天">
<meta property="og:locale" content="cn">
<meta property="article:author" content="husongtao">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">又是元气满满的一天</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://energygreek.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-redhat-reset-root-password" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/21/redhat-reset-root-password/" class="article-date">
  <time class="dt-published" datetime="2021-01-21T06:14:59.000Z" itemprop="datePublished">2021-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/21/redhat-reset-root-password/">redhat reset root password</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="rhel系列修改密码"><a href="#rhel系列修改密码" class="headerlink" title="rhel系列修改密码"></a>rhel系列修改密码</h1><p>考rhce8 栽在改密码了， 现在彻底弄明白</p>
<h2 id="关于selinux"><a href="#关于selinux" class="headerlink" title="关于selinux"></a>关于selinux</h2><p>这是rhel和其他发行版的最大区别，也是我忽略的点。启用selinux 时，改密码后，额外要执行<code>touch /.autorelabel</code>， 新密码才能生效，而平时我使用centos一直是禁用selinux的。</p>
<h2 id="启用selinux"><a href="#启用selinux" class="headerlink" title="启用selinux"></a>启用selinux</h2><p>selinux 默认状态是enforcing, 禁用时为disable, 通过<code>sestate</code> 查看状态。</p>
<h3 id="编译’-etc-selinux-config’"><a href="#编译’-etc-selinux-config’" class="headerlink" title="编译’/etc/selinux/config’"></a>编译’/etc/selinux/config’</h3><p>修改selinux配置，从disable 到enforcing</p>
<h3 id="执行两次下面动作"><a href="#执行两次下面动作" class="headerlink" title="执行两次下面动作"></a>执行两次下面动作</h3><p>创建这个文件的意义是重新label selinux, 不仅是当修改selinux配置需要做，在重置root密码时也是需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;.autorelabel</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="叙说改密"><a href="#叙说改密" class="headerlink" title="叙说改密"></a>叙说改密</h2><p>rhel5~8有两种方式重置密码，老版本为给linux启动参数加上’init=/bin/sh’, 新版本为加<code>rd.break</code><br>老版本适用于centos8（已测）, 而新版本应该不支持rhel5，6（未测），下面是完整步骤</p>
<h3 id="老版本"><a href="#老版本" class="headerlink" title="老版本"></a>老版本</h3><ol>
<li>进入grub界面，按e进入编辑启动参数，到linux 行，按ctrl+e或者end键到末尾，追加’init=/bin/sh’</li>
<li>按ctrl+x继续，系统自动进入内存文件系统的根目录</li>
<li>执行<code>/sbin/load_policy -i</code>来初始化selinux</li>
<li>此时系统处于ro模式，执行<code>mount -oremount,rw /</code> 重新挂载根分区，使系统可写</li>
<li><code>passwd</code> 设置root密码</li>
<li>如果启用了selinux, 额外要执行<code>touch /.autorelabel</code></li>
<li>最后执行<code>exit</code>或者 <code>exec /sbin/reboot</code> 或者<code>exec /sbin/init</code></li>
</ol>
<h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><ol>
<li>进入grub界面，按e进入编辑启动参数，到linux 行，按ctrl+e或者end键到末尾，追加’rd.break’</li>
<li>按ctrl+x继续，系统自动进入root系统，此时真正的文件系统以ro挂载在/sysroot</li>
<li>执行<code>mount -oremount,rw /sysrot</code> 重新挂载</li>
<li>执行<code>chroot /sysroot</code> 进入系统</li>
<li>执行<code>passwd</code>设置root密码</li>
<li>如果启用了selinux, 需要额外创建文件<code>touch /.autorelabel</code></li>
<li>执行<code>exit</code> 退出，然后执行 <code>umount /sysroot</code> 来确保写入</li>
<li>reboot 来重新进入</li>
</ol>
<h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><p>除了rhel系列的改密方式，任何发行版都可以通过光盘引导进修复模式来改密。  </p>
<p>最后，最简单暴力的方式就是用guestfish工具, 一条命令改密。当然只针对kvm虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-customize -a centos8.qcow2 --root-password password:123456</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2021/01/21/redhat-reset-root-password/" data-id="ckp6c7an3001gd1ok1e2me4u5" data-title="redhat reset root password" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintaince/" rel="tag">maintaince</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-weechat-manual" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/weechat-manual/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T10:19:42.000Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/weechat-manual/">weechat-manual</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="weechat-使用方法"><a href="#weechat-使用方法" class="headerlink" title="weechat 使用方法"></a>weechat 使用方法</h1><p>weechat 是一个irc客户端， 在终端中运行，不需要gui桌面，非常方便。 这里记录配置方法</p>
<p>主要参考<a href="https://samirparikh.com/blog/setting-up-weechat-commandline-irc-client.html" target="_blank" rel="noopener">链接</a></p>
<h2 id="安装和运行weechat"><a href="#安装和运行weechat" class="headerlink" title="安装和运行weechat"></a>安装和运行weechat</h2><p>安装后，直接在终端运行<code>weechat</code>，就能进入weechat</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="添加server"><a href="#添加server" class="headerlink" title="添加server"></a>添加server</h3><p>irc有很多server, 常用的是freenode。 另外有darkscience。 添加方法如下，另外weechat里面命令都是以’/‘ 开头，还能使用tab补全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;server add freenode chat.freenode.net&#x2F;6697 -ssl</span><br></pre></td></tr></table></figure>
<p>irc 除了有很多服务器url, 每个url 还有多个端口供链接，比如6697</p>
<h3 id="设置昵称"><a href="#设置昵称" class="headerlink" title="设置昵称"></a>设置昵称</h3><p>昵称默认是linux系统的用户名，昵称用来在聊天中显示名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;nick mynickname</span><br></pre></td></tr></table></figure>
<p>**注意：<br>手动修改昵称不是简单的事情，特别是当已经连接serer时。 比较方便的办法就是直接改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ～&#x2F;.weechat&#x2F;irc.conf</span><br><span class="line">nicks &#x3D; &quot;malloy,malloy1,malloy2&quot;</span><br></pre></td></tr></table></figure>
<p>带后缀的昵称用来当malloy占用时的备用，比如网络重连时昵称有冲突就需要备用昵称</p>
<h3 id="注册昵称"><a href="#注册昵称" class="headerlink" title="注册昵称"></a>注册昵称</h3><p>因为有很多聊天室要求注册后才能进入，所以先要使用邮箱注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;msg nickserv register userpassword example@email</span><br></pre></td></tr></table></figure>

<p>然后irc 会提示查收邮件，在邮件里面提示你在irc输入命令完成注册</p>
<h3 id="加入聊天室"><a href="#加入聊天室" class="headerlink" title="加入聊天室"></a>加入聊天室</h3><p>聊天室都是以#开头，例如我使用的 #archlinuxcn</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;join #weechat</span><br></pre></td></tr></table></figure>

<h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;parted &quot;leave message&quot;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;close</span><br></pre></td></tr></table></figure>

<h2 id="自动设置"><a href="#自动设置" class="headerlink" title="自动设置"></a>自动设置</h2><p>设置打开weechat时，自动登陆和自动进入聊天室</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;set irc.server.freenode.autoconnect on</span><br><span class="line">&#x2F;set irc.server.networkname.autojoin &quot;#channel1,#channel2&quot;</span><br></pre></td></tr></table></figure>

<h2 id="界面设置"><a href="#界面设置" class="headerlink" title="界面设置"></a>界面设置</h2><p>先介绍weechat的各名称对应命令 :<br>聊天室称为buffer, 切换聊天室命令 <code>/buffer n</code><br>最左边的聊天列表是bufferlist bar<br>进入buffer后，最右边的是nicklist bar，一个聊天室界面叫做window， 所以下面的命令设置就与 /bar /windows 有关</p>
<p>隐藏和显示bufferlist</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bar hiden bufferlist </span><br><span class="line">&#x2F;bar show bufferlist</span><br><span class="line">&#x2F;bar toggle bufferlist</span><br></pre></td></tr></table></figure>
<p>分屏显示所有聊天室，水平分屏splith,竖直分屏 splitev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;window splitv</span><br></pre></td></tr></table></figure>
<p>窗口切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;window +1</span><br><span class="line">&#x2F;window -1</span><br></pre></td></tr></table></figure>
<p>窗口合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;window merge</span><br></pre></td></tr></table></figure>

<h2 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h2><ol>
<li>上面添加服务器时，已经配置了ssl选项，就表示使用通讯加密了，但irc的聊天记录一般是对外公开的  </li>
<li>设置weechat开启密码， 进入weechat前验密<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;secure passphrase superSecretPassphrase</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="自动化设置和鉴权"><a href="#自动化设置和鉴权" class="headerlink" title="自动化设置和鉴权"></a>自动化设置和鉴权</h2><p>注册好昵称之后，配置自动化登陆，而不需要手动执行命令</p>
<p>设置irc登陆昵称，作为identify的参数，务必要跟register的保持一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;secure set networkname_nickname password</span><br></pre></td></tr></table></figure>
<p>设置irc登陆密码，作为identify的参数，务必要跟register的密码保持一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;secure set networkname_password password</span><br></pre></td></tr></table></figure>

<p>设置weechat启动时自动登陆服务器，以及自动加入channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;set irc.server.libera.autoconnect on</span><br><span class="line">&#x2F;set irc.server.libera.autojoin &quot;#archlinux-cn,#c,#c++&quot;</span><br></pre></td></tr></table></figure>
<p>以及自动验密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;set irc.server.networkname.command &quot;&#x2F;msg nickserv identify $&#123;sec.data.networkname_nickname&#125; $&#123;sec.data.network_password&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>其实显而易见地，<code>sec.data.networkname_nickname</code>和<code>sec.data.network_password</code> 都只是保存在sec.data里的变量，其实可以两个变量合成一条也没问题</p>
<h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>weechat有很多拓展插件，可以完成很多事情，比如自动回复，远程控制，连接telegram等, <a href="https://weechat.org/scripts/" target="_blank" rel="noopener">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2021/01/19/weechat-manual/" data-id="ckp6c7anl002ed1ok4rrmdnr1" data-title="weechat-manual" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weechat/" rel="tag">weechat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rancher-learn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/15/rancher-learn/" class="article-date">
  <time class="dt-published" datetime="2021-01-15T06:15:22.000Z" itemprop="datePublished">2021-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/15/rancher-learn/">rancher-learn</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2021/01/15/rancher-learn/" data-id="ckp6c7an2001ed1ok7hlne8k6" data-title="rancher-learn" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rancher-k8s/" rel="tag">rancher,k8s</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-udp-loader-balance" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/15/udp-loader-balance/" class="article-date">
  <time class="dt-published" datetime="2021-01-15T03:06:27.000Z" itemprop="datePublished">2021-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/15/udp-loader-balance/">udp loader balance</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="udp-的端口复用实现负载均衡"><a href="#udp-的端口复用实现负载均衡" class="headerlink" title="udp 的端口复用实现负载均衡"></a>udp 的端口复用实现负载均衡</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶尔看到 python 3.9 的release note 里面提到一个bug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asyncio¶</span><br><span class="line"></span><br><span class="line">出于重要的安全性考量，asyncio.loop.create_datagram_endpoint() 的 reuse_address 形参不再被支持。 这是由 UDP 中的套接字选项 SO_REUSEADDR 的行为导致的。 更多细节请参阅 loop.create_datagram_endpoint() 的文档。 （由 Kyle Stanley, Antoine Pitrou 和 Yury Selivanov 在 bpo-37228 中贡献。。）</span><br></pre></td></tr></table></figure>
<p>意思是tcp的socket option:SO_REUSEADDR不适用于udp：<br>在tcp中这个选项表示立即回收端口，减少 time_wait 的时间。而在udp中，这个选项表示多个socket可以绑定一个端口， 由内核来分发请求。</p>
<p>所以看到此功能，自己试了一下，确实如此， 顺便回顾一下知识</p>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct sockaddr_in addr;</span><br><span class="line">addr.sin_family &#x3D; AF_INET;</span><br><span class="line">addr.sin_port &#x3D; htons(8888);</span><br><span class="line">inet_pton(AF_INET,&quot;127.0.0.1&quot;,(void*)&amp;addr.sin_addr);</span><br><span class="line">&#x2F;&#x2F; inet_pton 支持ipv4和ipv6,是比较新的转换函数</span><br><span class="line"></span><br><span class="line">sfd &#x3D; socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">if(sfd &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">    perror(&quot;socket&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line">int val &#x3D; 1;</span><br><span class="line">if(0 !&#x3D; setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT,&amp;val, sizeof(val)))&#123;</span><br><span class="line">    perror(&quot;setsockopt&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* sockaddr 和 sockaddr_in 有什么区别？</span><br><span class="line">   struct sockaddr &#123;  </span><br><span class="line"> 	sa_family_t sin_family;&#x2F;&#x2F;地址族</span><br><span class="line">　　  	char sa_data[14]; &#x2F;&#x2F;14字节，包含套接字中的目标地址和端口信息               </span><br><span class="line">　　    &#125;; </span><br><span class="line">　　    struct sockaddr_in &#123;</span><br><span class="line">　　      sa_family_t sin_family;&#x2F;&#x2F;地址族</span><br><span class="line">　　      uint16_t sin_port;</span><br><span class="line">　　      struct in_addr sin_addr;	&#x2F;&#x2F; 32 位地址</span><br><span class="line">　　      char	sin_zero[8];	&#x2F;&#x2F; reserve</span><br><span class="line">　　    &#125;;</span><br><span class="line">　　    struct in_addr &#123;</span><br><span class="line">　　    	In_addr_t	s_addr;  &#x2F;&#x2F;32位</span><br><span class="line">　　    &#125;;</span><br><span class="line">　　    </span><br><span class="line">　　    sockaddr_in 和 sockaddr 长度相同，都 sin_family + 14 个字节，但是前者显式划分了</span><br><span class="line">　　 *&#x2F; </span><br><span class="line">if(bind(sfd, (struct  sockaddr*) &amp;addr, sizeof(addr)) !&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">    perror(&quot;bind&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>先启动两个服务端，再使用ncat 来模拟请求, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat -uv 0.0.0.0 8888</span><br></pre></td></tr></table></figure>

<p>启动ncat时，系统会分配给一个服务端处理。 但是重启ncat时， 会切换到另一个服务端处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2021/01/15/udp-loader-balance/" data-id="ckp6c7anh0025d1okhsewfplq" data-title="udp loader balance" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket-udp-socketopt/" rel="tag">socket, udp, socketopt</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-aliyun-dynamic-dns" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/04/aliyun-dynamic-dns/" class="article-date">
  <time class="dt-published" datetime="2021-01-04T10:23:15.000Z" itemprop="datePublished">2021-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/04/aliyun-dynamic-dns/">阿里云动态设置 dns</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果服务器的公网ip动态变化的情况下，如何访问，甚至如何通过域名访问？ </p>
<p>例如公司自己搭建的服务器如何暴露在公网上， 如果请求固定ip听说很贵， 还可以通过<code>frp</code>实现, 这里介绍2种方案</p>
<h2 id="动态dns"><a href="#动态dns" class="headerlink" title="动态dns"></a>动态dns</h2><p>前提是服务器有出口ip, 而不是在路由器下。 </p>
<ul>
<li>如果服务器在路由器下， 通过设置nat,将外网访问的请求的目的ip转换为局域网’192.168.<em>.</em>‘，也能实现公网请求局域网的服务器</li>
</ul>
<p>阿里云（相信大多数云厂商都支持） 可以支持动态改变dns的解析地址，即通过api调用就能改变dns的解析， 这样当出口ip变化时， 立即调用api来修改dns解析  </p>
<p>实现原理:</p>
<ol>
<li>定时检测出口ip, 例如每5分钟执行一次。 可以通过crontab和以下命令实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;httpbin.org&#x2F;ip</span><br></pre></td></tr></table></figure></li>
<li>通过阿里云的api操作dns</li>
<li>如果服务器在内网，添加nat规则，将目的ip转换为内网ip</li>
</ol>
<p>这里有个现成的<a href="https://github.com/NewFuture/DDNS" target="_blank" rel="noopener">项目</a></p>
<h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>frp 就是内网穿透了， 没有出口ip的情况下，例如在路由器下且路由器不支持nat的时候， 或者是在运营商级NAT的模式下，就可以采取这中方式。 但是前提是需要有公网的服务器</p>
<p>实现原理：</p>
<ol>
<li>通过在公网服务器运行frp 服务端， 在没有出口ip的局域网服务器上运行frp客户端</li>
<li>客户端主动去连接服务端， 连接上之后， 服务端会为客户端创建一个端口， 所有的向这个端口的请求都被转发到局域网的服务器，实现公网访问局域网的服务器</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果有出口ip, 即使经常变化， 可以使用动态dns的技术实现暴露到公网， 成本低廉。 否则使用frp,需要额外购买服务器，或者使用花生壳类似的穿透技术， 但是有被掏裤裆的风险</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2021/01/04/aliyun-dynamic-dns/" data-id="ckp6c7am60005d1okdmbkba4j" data-title="阿里云动态设置 dns" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dns/" rel="tag">dns</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-crash-boot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/04/crash-boot/" class="article-date">
  <time class="dt-published" datetime="2021-01-04T09:47:05.000Z" itemprop="datePublished">2021-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/04/crash-boot/">crash boot</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>元旦过完回公司发现archlinux 系统无法启动了， 提示没有找到内核之类的错误。 虽然也没有找到根本原因，只知道是内核镜像丢失了， 这里记一下解决办法</p>
<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>启动之后， 提示缺少内核， 需要先指定内核。 回车后进入grub 界面。 在grub 界面可以执行ls (hd<em>,gpt</em>)/ 来查看分区的文件<br>hd0、 hd1 代表的硬盘编号， gpt1、 gpt2、 gpt3 代表分区， ls (hd0, gpt1)/ 表示查看第一个硬盘第一个分区的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls (hd1, gpt2)</span><br><span class="line">EFI  grub  initramfs-linux-fallback.img</span><br></pre></td></tr></table></figure>

<p>我的boot分区是第二个硬盘的第二个分区， 可见确实没有 vmlinuz-linux 文件，也很奇怪</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>没有 ‘vmlinuz-linux’ 文件的话需要通过archlinux的U盘启动盘启动， 挂载分区后，arch-chroot 进入到坏系统  </p>
<p>执行重装linux </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S linux</span><br></pre></td></tr></table></figure>
<p>执行grub 相关命令， 重建引导配置。 我的EFI单独分区了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target&#x3D;x86_64-efi --efi-directory&#x3D;&#x2F;boot&#x2F;EFI --bootloader-id&#x3D;Arch</span><br><span class="line">grub-config -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg</span><br></pre></td></tr></table></figure>

<p><code>exit</code>退出坏系统，umount 再重启。 一定要umount 分区否则grub不会生效</p>
<h2 id="没有umount-导致的grub不生效"><a href="#没有umount-导致的grub不生效" class="headerlink" title="没有umount 导致的grub不生效"></a>没有umount 导致的grub不生效</h2><p>因为没有umount，<code>exit</code>后直接重启， 发现依旧无法进入系统，还是进入了grub界面，好在linux内核镜像已经存在了，可以通过grub来配置启动<br>所以这种情况也适用于系统ok，但引导损坏的情况。</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>我的boot分区是(hd1,gpt2)</p>
<p>执行一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set prefix&#x3D;(hd1,gpt2)&#x2F;grub&#x2F;  # 指定实际的grub目录</span><br><span class="line">set root&#x3D;(hd1,gp2)</span><br><span class="line">insmod normal</span><br><span class="line">normal</span><br></pre></td></tr></table></figure>

<p>此时grub会刷新， 继续执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insmod linux</span><br><span class="line">linux &#x2F;vmlinuz-linux root&#x3D;&#x2F;dev&#x2F;nvme0n1p2   # 设置内核</span><br><span class="line">initrd &#x2F;initd.img</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>

<p>由于不知道nvme的命名方式，导致也挺麻烦， grub下可以看到uuid,但不能看到分区名称， 后来发现可以通过uuid方式指定root</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insmod linux</span><br><span class="line">linux &#x2F;vmlinuz root&#x3D;UUID&#x3D;xxxxxxxxxxx</span><br><span class="line">initrd &#x2F;initd.img</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>

<h2 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h2><p>同样可以通过磁盘+分区的方式指定内核和initrd</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2021/01/04/crash-boot/" data-id="ckp6c7amd000dd1ok3y3t7jk3" data-title="crash boot" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/grub/" rel="tag">grub</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux-perm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/20/linux-perm/" class="article-date">
  <time class="dt-published" datetime="2020-11-20T08:37:29.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/20/linux-perm/">linux perm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux-权限位"><a href="#linux-权限位" class="headerlink" title="linux 权限位"></a>linux 权限位</h1><p>linux的权限位用来定义文件和目录的权限，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/20/linux-perm/" data-id="ckp6c7amo000ud1ok3fo4hxz5" data-title="linux perm" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%9F%BA%E7%A1%80/" rel="tag">linux基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-binary-tree-traversal" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/binary-tree-traversal/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T11:01:54.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/18/binary-tree-traversal/">binary tree traversal</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><p>二叉树的父节点最多有2个子节点，如果二叉树的所有父节点没有节点或者有2个节点，那么叫完全二叉树</p>
<h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>二叉树有4中遍历方式： 前序遍历， 中序， 后序， 以及层序  </p>
<p>前三种可以对比着看，区别在于父节点先被访问的顺序，这里的先后都是相对于同一个树而言。 这里的访问意思是访问其值， 例如打印节点的数据：  </p>
<ul>
<li>前序遍历， 先父节点，再左子节点，最后是右子节点 </li>
<li>中序遍历， 先左子节点， 再父节点， 最后是右子节点</li>
<li>中序遍历， 先左子节点， 再右子节点 ，最后父节点</li>
</ul>
<p>可见，都是先左子节点后右子节点  </p>
<p>而层序遍历是从上往下，广度优先</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>若有以下二叉树，则遍历结果</p>
<pre class="mermaid">graph BT
    A[1] --> B[0]
    C[2] --> B
    D[3] --> A
    E[4] --> A
    F[5] --> C
    G[6] --> C
    H[7] --> D
    I[8] --> D
    J[9] --> E</pre>

<p>层序: 0 1 2 3 4 5 6 7 8 9</p>
<p>先序: <u>0</u> 1 <u>3</u> 7 8 4 9 2 5 <u>6</u><br>中序: 7 <u>3</u> 8 1 9 4 <u>0</u> 5 2 <u>6</u><br>后序: 7 8 <u>3</u> 9 4 1 5 <u>6</u> 2 <u>0</u>  </p>
<p>注意下划线，即036组成的一个树， 可以证实上面的总结  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现前三种遍历都有2种方式， 递归和使用stack</p>
<p>节点数据结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Node</span>:</span></span><br><span class="line">    self.item</span><br><span class="line">    self.lchild</span><br><span class="line">    self.rchild</span><br></pre></td></tr></table></figure>

<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">front_recursion</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    print(root.item)</span><br><span class="line">    <span class="keyword">if</span> root.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.lchild)</span><br><span class="line">    <span class="keyword">if</span> root.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.rchild)</span><br></pre></td></tr></table></figure>

<p>中序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Middle_recursion</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.lchild)</span><br><span class="line">    print(root.item)</span><br><span class="line">    <span class="keyword">if</span> root.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.rchild)</span><br></pre></td></tr></table></figure>

<p>后序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Middle_recursion</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.lchild)</span><br><span class="line">    <span class="keyword">if</span> root.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        front_recursion(root.rchild)</span><br><span class="line">    print(root.item)</span><br></pre></td></tr></table></figure>

<h3 id="stack实现"><a href="#stack实现" class="headerlink" title="stack实现"></a>stack实现</h3><p>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Front_stack</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    stack = []</span><br><span class="line">    Node = root</span><br><span class="line">    stack.append(Node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Node <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> Node:</span><br><span class="line">			<span class="comment"># 访问和入栈的顺序顺序是先父节点后左节点</span></span><br><span class="line">            print(Node.item)</span><br><span class="line">            <span class="comment"># 父节点入栈</span></span><br><span class="line">            stack.append(Node.lchild)</span><br><span class="line">            <span class="comment"># 深度优先，找最左节点，下个循环就是先访问父节点后左子节点</span></span><br><span class="line">            Node = Node.lchild</span><br><span class="line">        <span class="comment"># 这里需要好好体会，父节点和左子节点已经访问过，只剩下右节点</span></span><br><span class="line">        <span class="comment"># 所以就是先左后右</span></span><br><span class="line">        Node = stack.pop()</span><br><span class="line">        Node = Node.rchild</span><br></pre></td></tr></table></figure>

<p>中序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Middle_stack</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    stack = []</span><br><span class="line">    Node = root</span><br><span class="line">    stack.append(Node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Node <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> Node:</span><br><span class="line">            <span class="comment"># 父节点入栈</span></span><br><span class="line">            <span class="comment"># 左子节点入栈</span></span><br><span class="line">            <span class="comment"># 但都不访问，因为压栈顺序是先父后左子，到出栈的时候再访问</span></span><br><span class="line">            stack.append(Node.lchild)</span><br><span class="line">            Node = Node.lchild</span><br><span class="line"></span><br><span class="line">        Node = stack.pop()</span><br><span class="line">        <span class="comment"># 找到最左子节点了，开始出栈，所以肯定是先出左节点， 然后再出栈之后就是父节点</span></span><br><span class="line">        print(Node.item)</span><br><span class="line">        <span class="comment"># 最后就是右节点， 回到第一个while 继续找右子树的最左节点</span></span><br><span class="line">        Node = Node.rchild</span><br></pre></td></tr></table></figure>

<p>后序的stack比较复杂</p>
<p>还有一个比较简单的先序stack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Front_stack</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        Node = stack.pop()</span><br><span class="line">        print(Node.item)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack 先进后出，所以先压右节点</span></span><br><span class="line">        <span class="keyword">if</span> Node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(Node.rchild)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> Node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(Node.lchild)</span><br></pre></td></tr></table></figure>

<p>层序遍历,是广度优先的一种方式，所以使用到queue</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Layer_queue</span><span class="params">(root: Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment"># 取前面的</span></span><br><span class="line">        Node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        print(Node.item)</span><br><span class="line">        <span class="keyword">if</span> Node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(Node.lchild)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> Node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(Node.rchild)</span><br></pre></td></tr></table></figure>

<h3 id="后序栈遍历"><a href="#后序栈遍历" class="headerlink" title="后序栈遍历"></a>后序栈遍历</h3><p>后序遍历的顺序是先左子后右子，最后才是父节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1. 同样先找到最左边的节点，父节点和左子节点入栈</span></span><br><span class="line"><span class="string">2. 找到最后一个左子节点之后，判断栈顶的节点，出栈顺序是先左子后父节点，所以只需要判断右子节点的情况：</span></span><br><span class="line"><span class="string">   如果栈顶节点的右子节点为空，直接打印栈顶节点。 如果栈顶节点的右子节点是上一个出栈的节点，那么说明已经访问到了右子节点，可以继续打印父节点  </span></span><br><span class="line"><span class="string">   如果栈顶的右子节点不为空也不是上一个访问的节点，所以要先去访问右子树， 将右子节点入栈，退出循环，执行第一步</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back_stack</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    stack = []</span><br><span class="line">    Tag = <span class="literal">None</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        Node = stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> Node.lchild:</span><br><span class="line">            stack.append(Node.lchild)</span><br><span class="line">            Node = Node.lchild</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            Node = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> Tag == Node.rchild <span class="keyword">or</span> Node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                Node = stack.pop()</span><br><span class="line">                print(Node.item)</span><br><span class="line">                Tag = Node</span><br><span class="line">            <span class="keyword">elif</span> Node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(Node.rchild)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/18/binary-tree-traversal/" data-id="ckp6c7ama0009d1ok3kve7qm1" data-title="binary tree traversal" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker-overlay-filesystem" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/docker-overlay-filesystem/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T01:38:41.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/18/docker-overlay-filesystem/">docker overlay filesystem</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="overlay-是docker使用的文件系统，具有分层的特点"><a href="#overlay-是docker使用的文件系统，具有分层的特点" class="headerlink" title="overlay 是docker使用的文件系统，具有分层的特点"></a>overlay 是docker使用的文件系统，具有分层的特点</h1><p>docker使用的文件系统经过很多变化，而且各发行版可能不同。<br>执行<code>docker info</code> 查看当前使用的是overlay2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info | grep -i storage                                                                                                                                              </span><br><span class="line"> Storage Driver: overlay2</span><br></pre></td></tr></table></figure>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>除了 overlay，类似有rootfs， aufs （ubuntu）， devicemapper（centos），不够成熟的btrfs</p>
<p>他们都有2个目的：  </p>
<ol>
<li>提供不含内核的文件系统（rootfs）即容器, 在内核之上。这是docker 最有价值的地方，就是无论在那里运行docker， 容器里的环境都是一致的</li>
<li>提供分层</li>
</ol>
<h2 id="overlay的优势"><a href="#overlay的优势" class="headerlink" title="overlay的优势"></a>overlay的优势</h2><ol>
<li>page caching， 可以在多个不同实例之间共享</li>
<li>写时复制， 只有执行write操作时， 会将lower layer 的文件复制到container层</li>
<li>不同层之间，相同文件使用硬连接， 节省inode 和 大小</li>
</ol>
<p>写时复制 copy-up 会导致第一次写时造成延迟，特别是大文件，拷贝起来费时。 但第二次就不会延时， 而且overlay2 有caching， 相比其它文件系统，更减少延时</p>
<h2 id="overlay的问题"><a href="#overlay的问题" class="headerlink" title="overlay的问题"></a>overlay的问题</h2><ol>
<li>实现不够完全， 例如没有实现uname </li>
<li>先只读打开一个文件 open（read）， 再读写打开相同文件open（write）， 两个fd 会对应2个不同文件， 第一个对应的lower的文件，第二个造成写时复制，对应容器里的文件。 <ul>
<li>规避方法是先执行touch 操作。 现实的例子是 yum 需要安装yum-plugin-ovl。 但这个只有7.2才支持， 之前的话就需要先<code>touch /var/lib/rpm/*</code></li>
</ul>
</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>使用ssd </li>
<li>对于写操作比较多的目录， 使用映射文件。这样跳过了overlay的复杂操作，直接使用主机的文件系统。</li>
</ol>
<h2 id="分层介绍"><a href="#分层介绍" class="headerlink" title="分层介绍"></a>分层介绍</h2><p>我理解就是将分离的多个目录挂载到一起的技术。<br>例如对docker 容器的文件进行增删改后，再commit， 会多一层layer。<br>再当docker 容器启动时，会自动挂载多层layer。<br><strong><em>组织</em></strong>： overlay对运行的实例通过元数据组织文件， 是否是link文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls 04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;</span><br><span class="line">diff  link  lower  merged  work</span><br></pre></td></tr></table></figure>

<h3 id="手动mount的例子"><a href="#手动mount的例子" class="headerlink" title="手动mount的例子"></a>手动mount的例子</h3><ol>
<li>原本目录，文件都分散在不同目录ABC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── aa</span><br><span class="line">│   └── a.txt</span><br><span class="line">├── B</span><br><span class="line">│   ├── a.txt</span><br><span class="line">│   └── b.txt</span><br><span class="line">├── C</span><br><span class="line">│   └── c.txt</span><br><span class="line">└── worker</span><br><span class="line">    └── work [error opening dir]</span><br></pre></td></tr></table></figure></li>
<li>overlay 挂载到/tmp/test目录 <code>sudo mount -t overlay overlay -o lowerdir=A:B,upperdir=C,workdir=worker /tmp/test/</code></li>
<li>查看test目录 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;tmp&#x2F;test&#x2F;</span><br><span class="line">├── aa</span><br><span class="line">├── a.txt</span><br><span class="line">├── b.txt</span><br><span class="line">└── c.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount  | grep &#39;overlay&#39;</span><br><span class="line">overlay on &#x2F;tmp&#x2F;test type overlay (rw,relatime,lowerdir&#x3D;A:B,upperdir&#x3D;C,workdir&#x3D;worker)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="overlay的增删改"><a href="#overlay的增删改" class="headerlink" title="overlay的增删改"></a>overlay的增删改</h3><p>当运行docker容器时查看挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">overlay on &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;merged type overlay </span><br><span class="line">(rw,relatime,</span><br><span class="line">	lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;B74PWZCBMRCWXFH5UL2ZXB5WEU:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;WNHICVPVSDNUGSCZW435TPSMOK,</span><br><span class="line">	upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;diff,</span><br><span class="line">	workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;04ea1faa8074e5862f40eecdba968bd9b7f222cb30e5bf6a0b9a9c48be0940f2&#x2F;work</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>docker 将镜像的文件挂载为只读， 将容器层挂载为可读可写。 文件系统可以分为2部分<br>upper（容器层） + lower （镜像层）</p>
<ul>
<li>当在容器里执行写时， 如果文件不存在， 会依次遍历lower。如果都不存在就会在upper层创建文件</li>
<li>读也相同</li>
<li>删除时会创建一个without 来隐藏， 这是为什么即使删除容器里的文件， 镜像还是会增大。 </li>
<li>删除目录情况也差不多</li>
</ul>
<p>似乎很奇怪，为什么多了一个workdir,  据说这个目录总是空的，为了实现原子操作添加和删除文件</p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>在修改容器后， 容器系统会多一层， 里面包含了修改的文件，以及删除后生成的without文件， 然后生成镜像</p>
<p>但对于以下特殊目录文件不会提交， 因为这些文件是运行时docker 要根据用户配置进行修改的。  </p>
<ol>
<li>/etc/hostname </li>
<li>/etc/hosts </li>
<li>/etc/resov.conf</li>
</ol>
<p>例如docker 的link选项，会在容器的hosts 文件里定义对应的容器名-&gt;容器ip</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/18/docker-overlay-filesystem/" data-id="ckp6c7amh000jd1ok296f8ne3" data-title="docker overlay filesystem" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker-filesystem/" rel="tag">docker, filesystem</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-进程的内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-11-17T06:07:25.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">进程的内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://energygreek.github.io/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckp6c7anm002hd1ok51cben5y" data-title="进程的内存管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/" rel="tag">Linux 内核原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aarch64/" rel="tag">aarch64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-c/" rel="tag">c/c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dns/" rel="tag">dns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-filesystem/" rel="tag">docker, filesystem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/experience/" rel="tag">experience</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filesystem/" rel="tag">filesystem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grub/" rel="tag">grub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">linux 系统调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%9F%BA%E7%A1%80/" rel="tag">linux基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lvm/" rel="tag">lvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maintaince/" rel="tag">maintaince</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-shared-ptr-unique-ptr-exception-safe/" rel="tag">memory,shared_ptr,unique_ptr,exception-safe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/misc/" rel="tag">misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/printer-linux/" rel="tag">printer linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/program-lock/" rel="tag">program,lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-%E5%8C%85%E7%AE%A1%E7%90%86/" rel="tag">python 包管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rancher-k8s/" rel="tag">rancher,k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rhce8/" rel="tag">rhce8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/safe/" rel="tag">safe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket-udp-socketopt/" rel="tag">socket, udp, socketopt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sysemd-%E8%BF%90%E7%BB%B4/" rel="tag">sysemd, 运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/systemd-tmpfile/" rel="tag">systemd,tmpfile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/terminal-urxvt/" rel="tag">terminal,urxvt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weechat/" rel="tag">weechat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux-%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/" style="font-size: 10px;">Linux 内核原理</a> <a href="/tags/aarch64/" style="font-size: 10px;">aarch64</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/c/" style="font-size: 20px;">c++</a> <a href="/tags/c-c/" style="font-size: 13.33px;">c/c++</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/dns/" style="font-size: 10px;">dns</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/docker-filesystem/" style="font-size: 10px;">docker, filesystem</a> <a href="/tags/experience/" style="font-size: 10px;">experience</a> <a href="/tags/filesystem/" style="font-size: 10px;">filesystem</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 10px;">linux 系统调用</a> <a href="/tags/linux%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">linux基础</a> <a href="/tags/lvm/" style="font-size: 10px;">lvm</a> <a href="/tags/maintaince/" style="font-size: 10px;">maintaince</a> <a href="/tags/memory-shared-ptr-unique-ptr-exception-safe/" style="font-size: 10px;">memory,shared_ptr,unique_ptr,exception-safe</a> <a href="/tags/misc/" style="font-size: 10px;">misc</a> <a href="/tags/printer-linux/" style="font-size: 10px;">printer linux</a> <a href="/tags/program-lock/" style="font-size: 10px;">program,lock</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/python-%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 10px;">python 包管理</a> <a href="/tags/rancher-k8s/" style="font-size: 10px;">rancher,k8s</a> <a href="/tags/rhce8/" style="font-size: 10px;">rhce8</a> <a href="/tags/safe/" style="font-size: 13.33px;">safe</a> <a href="/tags/socket-udp-socketopt/" style="font-size: 10px;">socket, udp, socketopt</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/sysemd-%E8%BF%90%E7%BB%B4/" style="font-size: 10px;">sysemd, 运维</a> <a href="/tags/systemd-tmpfile/" style="font-size: 10px;">systemd,tmpfile</a> <a href="/tags/terminal-urxvt/" style="font-size: 10px;">terminal,urxvt</a> <a href="/tags/tool/" style="font-size: 16.67px;">tool</a> <a href="/tags/weechat/" style="font-size: 10px;">weechat</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/13/manage-temporary-file-with-systemd-tmpfiles/">使用systemd-tmpfiles来管理临时文件</a>
          </li>
        
          <li>
            <a href="/2021/04/02/ways-to-use-third-party-library-in-cmake/">cmake 使用第三方库</a>
          </li>
        
          <li>
            <a href="/2021/03/25/my-urxvt/">urxvt配置</a>
          </li>
        
          <li>
            <a href="/2021/03/17/static-compile-warning-if-namespace-resolving-function-used/">static compile warning if namespace resolving function used</a>
          </li>
        
          <li>
            <a href="/2021/03/15/shared-pointer/">智能指针</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 husongtao<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>